
Here’s a rough outline of how we could evolve the current Git-centric stack into a pluggable VCS
  architecture while keeping behavior identical for Git users:
 
  1. Define a VcsRepository contract
      - Create a trait in a new vcs crate that mirrors the services the rest of Zed expects: status
        snapshots, diff bases, blame, history metadata, commit actions, remote ops, etc.
      - Associate capability flags (e.g., HasIndex, HasBranches, HasRemotes, SupportsPartialStaging,
        SupportsBlame) so callers can branch on features without stringly-typed checks. Git’s adapter
        implements the full contract; a future jj adapter advertises only the subset it supports.
  2. Introduce a VcsService facade in project
      - Replace Project::git_store() with Project::vcs_service() exposing high-level operations
        (open_diff, fetch_status, apply_hunk), internally dispatching to the active backend per
        repository.
      - The service holds multiple backends keyed by repo id: a GitBackend wrapping today’s GitStore/
        Repository, and later a JjBackend.
      - UI and tools call the facade, not Git types directly.
  3. Decouple worktree from Git specifics
      - Keep the filesystem scanner as-is but have it emit generic VcsRepositoryDescriptor entries:
        {kind: Git|Jj|…, workdir_path, metadata_path}.
      - For Git descriptors we instantiate the existing GitRepository; for jj descriptors we can create
        lightweight handles that call into jj’s tracker helpers / jj-lib.
      - The descriptors flow through WorktreeStoreEvent::WorktreeUpdatedRepositories with a VcsKind field
        so higher layers know which backend to update.
  4. Adapt existing Git logic into an adapter
      - Wrap GitStore in a GitVcsBackend that implements the new trait using today’s methods
        (GitRepository, GitStatus, etc.).
      - The adapter is responsible for translating capability queries and mapping VcsOperation requests
        to the underlying Git actions (stage, branch create, blame, etc.).
      - Because the adapter lives in crates/git, Git-specific types (e.g., UpstreamTrackingStatus) stay
        localized.
  5. UI remains per-backend
      - The generic service determines which panel(s) to show: if the repo advertises HasIndex, load the
        Git panel; if it advertises SupportsChangesGraph but no staging, we can show a jj-specific panel.
      - Until we build a jj panel, the UI simply suppresses Git-only chrome for jj repos, while still
        enabling shared features (inline diff, blame) via the generic service.
  6. Gradual migration path
      - Phase 1: implement the trait + service, with Git as the only backend. Refactor current call sites
        to the generic API without changing behavior.
      - Phase 2: plug the JjTracker into the descriptor system and add a skeleton JjBackend that at least
        reports presence/capabilities and calls jj file diff/jj annotate for shared features.
      - Phase 3: grow jj-specific UI/actions as the backend gains capabilities.
 
  This approach keeps current Git functionality untouched while giving us a clear seam for jj (and
  other VCS) to integrate. It also lets us adopt jj incrementally: once the service and trait exist,
  the initial jj backend can start by implementing only the shared capabilities (diff/blame) and we can
  expand from there.
